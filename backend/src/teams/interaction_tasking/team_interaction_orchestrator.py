"""
Team Interaction & Tasking Orchestrator

Orchestrator ch√≠nh cho TEAM Interaction & Tasking, t√≠ch h·ª£p t·∫•t c·∫£ c√°c agent:
- UserIntentParserAgent: Ph√¢n t√≠ch √Ω ƒë·ªãnh ng∆∞·ªùi d√πng
- DialogManagerAgent: Qu·∫£n l√Ω h·ªôi tho·∫°i
- ConfigurationManagementAgent: Qu·∫£n l√Ω c·∫•u h√¨nh LLM
- TaskInitiationModule: T·∫°o TaskDefinition
- PresentationModule: Hi·ªÉn th·ªã k·∫øt qu·∫£

ƒê√¢y l√† giao di·ªán ch√≠nh ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi TEAM n√†y.
"""

from typing import Dict, Any, Optional
from dataclasses import dataclass

from shared.utils.logging_config import get_logger, log_function_entry, log_function_exit
from .user_intent_parser_agent import UserIntentParserAgent, UserIntent
from .dialog_manager_agent import DialogManagerAgent, DialogContext, DialogResponse, DialogState
from .configuration_management_agent import ConfigurationManagementAgent
from .task_initiation_module import TaskInitiationModule
from .presentation_module import PresentationModule


@dataclass
class InteractionSession:
    """Session t∆∞∆°ng t√°c v·ªõi ng∆∞·ªùi d√πng"""
    session_id: str
    user_id: str
    dialog_context: DialogContext
    is_active: bool = True
    
    def get_conversation_history(self) -> str:
        """L·∫•y l·ªãch s·ª≠ h·ªôi tho·∫°i d∆∞·ªõi d·∫°ng text"""
        history = []
        for msg in self.dialog_context.conversation_history:
            role = "üë§ User" if msg["role"] == "user" else "ü§ñ Assistant"
            history.append(f"{role}: {msg['content']}")
        return "\n\n".join(history)


class TeamInteractionOrchestrator:
    """
    Orchestrator ch√≠nh cho TEAM Interaction & Tasking.
    
    Ch·ª©c nƒÉng ch√≠nh:
    - ƒêi·ªÅu ph·ªëi t·∫•t c·∫£ c√°c agent trong TEAM
    - Qu·∫£n l√Ω session t∆∞∆°ng t√°c ng∆∞·ªùi d√πng
    - X·ª≠ l√Ω end-to-end flow t·ª´ input ƒë·∫øn output
    - T√≠ch h·ª£p v·ªõi c√°c TEAM kh√°c th√¥ng qua TaskDefinition
    """
    
    def __init__(self):
        """Kh·ªüi t·∫°o Team Interaction Orchestrator"""
        self.logger = get_logger("team.interaction.orchestrator")
        
        # Kh·ªüi t·∫°o c√°c agent
        self.intent_parser = UserIntentParserAgent()
        self.dialog_manager = DialogManagerAgent()
        self.config_manager = ConfigurationManagementAgent()
        self.task_initiator = TaskInitiationModule()
        self.presentation = PresentationModule()
        
        # Qu·∫£n l√Ω sessions
        self._active_sessions: Dict[str, InteractionSession] = {}
        
        self.logger.info("Kh·ªüi t·∫°o TeamInteractionOrchestrator th√†nh c√¥ng")
    
    def start_new_session(self, user_id: str, session_id: Optional[str] = None) -> InteractionSession:
        """
        B·∫Øt ƒë·∫ßu session t∆∞∆°ng t√°c m·ªõi v·ªõi ng∆∞·ªùi d√πng.
        
        Args:
            user_id: ID c·ªßa ng∆∞·ªùi d√πng
            session_id: ID session (t·ª± ƒë·ªông t·∫°o n·∫øu kh√¥ng cung c·∫•p)
            
        Returns:
            InteractionSession m·ªõi
        """
        log_function_entry(self.logger, "start_new_session", user_id=user_id, session_id=session_id)
        
        try:
            # T·∫°o session ID n·∫øu ch∆∞a c√≥
            if not session_id:
                import uuid
                session_id = str(uuid.uuid4())
            
            # Kh·ªüi t·∫°o dialog context
            dialog_context = self.dialog_manager.__init_session()
            
            # T·∫°o session
            session = InteractionSession(
                session_id=session_id,
                user_id=user_id,
                dialog_context=dialog_context,
                is_active=True
            )
            
            # L∆∞u v√†o active sessions
            self._active_sessions[session_id] = session
            
            self.logger.info(f"T·∫°o session m·ªõi th√†nh c√¥ng: {session_id} cho user {user_id}")
            log_function_exit(self.logger, "start_new_session", result="success")
            
            return session
            
        except Exception as e:
            self.logger.error(f"L·ªói khi t·∫°o session m·ªõi: {e}", exc_info=True)
            log_function_exit(self.logger, "start_new_session", result="error")
            raise
    
    def process_user_message(self, session_id: str, user_message: str) -> Dict[str, Any]:
        """
        X·ª≠ l√Ω tin nh·∫Øn t·ª´ ng∆∞·ªùi d√πng trong m·ªôt session.
        
        Args:
            session_id: ID c·ªßa session
            user_message: Tin nh·∫Øn t·ª´ ng∆∞·ªùi d√πng
            
        Returns:
            Dict ch·ª©a ph·∫£n h·ªìi v√† th√¥ng tin tr·∫°ng th√°i
        """
        log_function_entry(self.logger, "process_user_message", 
                          session_id=session_id, user_message=user_message[:100])
        
        try:
            # L·∫•y session
            session = self._get_session(session_id)
            if not session:
                return self._create_error_response("Session kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ h·∫øt h·∫°n")
            
            # 1. Ph√¢n t√≠ch √Ω ƒë·ªãnh ng∆∞·ªùi d√πng
            user_intent = self.intent_parser.parse_user_intent(user_message)
            
            self.logger.info(f"Intent ph√¢n t√≠ch: {user_intent.intent_type.value}, confidence: {user_intent.confidence}")
            
            # 2. X·ª≠ l√Ω v·ªõi Dialog Manager
            dialog_response = self.dialog_manager.process_user_input(
                user_message, 
                session.dialog_context, 
                user_intent
            )
            
            # 3. Ki·ªÉm tra xem c√≥ c·∫ßn th·ª±c hi·ªán task kh√¥ng
            task_definition = None
            if dialog_response.should_execute_task and dialog_response.task_params:
                # L·∫•y c·∫•u h√¨nh LLM cho user
                user_config = self.config_manager.get_user_configuration(session.user_id)
                
                # T·∫°o TaskDefinition v·ªõi c·∫•u h√¨nh LLM
                task_definition = self._create_task_definition(
                    dialog_response.task_params,
                    user_config.llm_configs
                )
            
            # 4. ƒê·ªãnh d·∫°ng ph·∫£n h·ªìi cu·ªëi c√πng
            formatted_response = self.presentation.format_dialog_response(dialog_response)
            
            # 5. Chu·∫©n b·ªã response
            response = {
                "session_id": session_id,
                "message": formatted_response,
                "state": dialog_response.state.value,
                "intent_type": user_intent.intent_type.value,
                "intent_confidence": user_intent.confidence,
                "suggested_actions": dialog_response.suggested_actions,
                "task_ready": dialog_response.should_execute_task,
                "task_definition": task_definition.to_dict() if task_definition else None,
                "conversation_length": len(session.dialog_context.conversation_history)
            }
            
            self.logger.info(f"X·ª≠ l√Ω tin nh·∫Øn th√†nh c√¥ng, state: {dialog_response.state.value}")
            log_function_exit(self.logger, "process_user_message", result="success")
            
            return response
            
        except Exception as e:
            self.logger.error(f"L·ªói khi x·ª≠ l√Ω tin nh·∫Øn ng∆∞·ªùi d√πng: {e}", exc_info=True)
            log_function_exit(self.logger, "process_user_message", result="error")
            return self._create_error_response(f"ƒê√£ x·∫£y ra l·ªói: {str(e)}")
    
    def get_session_info(self, session_id: str) -> Optional[Dict[str, Any]]:
        """
        L·∫•y th√¥ng tin session.
        
        Args:
            session_id: ID c·ªßa session
            
        Returns:
            Th√¥ng tin session ho·∫∑c None n·∫øu kh√¥ng t·ªìn t·∫°i
        """
        session = self._get_session(session_id)
        if not session:
            return None
        
        return {
            "session_id": session.session_id,
            "user_id": session.user_id,
            "is_active": session.is_active,
            "state": session.dialog_context.state.value,
            "conversation_length": len(session.dialog_context.conversation_history),
            "last_question": session.dialog_context.last_question,
            "gathered_info": session.dialog_context.gathered_info
        }
    
    def get_conversation_history(self, session_id: str) -> Optional[str]:
        """
        L·∫•y l·ªãch s·ª≠ h·ªôi tho·∫°i c·ªßa session.
        
        Args:
            session_id: ID c·ªßa session
            
        Returns:
            L·ªãch s·ª≠ h·ªôi tho·∫°i d∆∞·ªõi d·∫°ng text
        """
        session = self._get_session(session_id)
        if not session:
            return None
        
        return session.get_conversation_history()
    
    def end_session(self, session_id: str) -> bool:
        """
        K·∫øt th√∫c session.
        
        Args:
            session_id: ID c·ªßa session
            
        Returns:
            True n·∫øu th√†nh c√¥ng
        """
        log_function_entry(self.logger, "end_session", session_id=session_id)
        
        try:
            if session_id in self._active_sessions:
                session = self._active_sessions[session_id]
                session.is_active = False
                del self._active_sessions[session_id]
                
                self.logger.info(f"K·∫øt th√∫c session th√†nh c√¥ng: {session_id}")
                log_function_exit(self.logger, "end_session", result="success")
                return True
            else:
                self.logger.warning(f"Session kh√¥ng t·ªìn t·∫°i: {session_id}")
                log_function_exit(self.logger, "end_session", result="not_found")
                return False
                
        except Exception as e:
            self.logger.error(f"L·ªói khi k·∫øt th√∫c session: {e}", exc_info=True)
            log_function_exit(self.logger, "end_session", result="error")
            return False
    
    def update_user_llm_config(self, user_id: str, team_name: str, 
                              provider: str, model_name: str, 
                              **kwargs) -> bool:
        """
        C·∫≠p nh·∫≠t c·∫•u h√¨nh LLM cho user.
        
        Args:
            user_id: ID ng∆∞·ªùi d√πng
            team_name: T√™n TEAM
            provider: Nh√† cung c·∫•p LLM
            model_name: T√™n model
            **kwargs: C√°c tham s·ªë kh√°c (temperature, max_tokens, etc.)
            
        Returns:
            True n·∫øu c·∫≠p nh·∫≠t th√†nh c√¥ng
        """
        log_function_entry(self.logger, "update_user_llm_config", 
                          user_id=user_id, team_name=team_name, 
                          provider=provider, model_name=model_name)
        
        try:
            from .configuration_management_agent import LLMConfiguration, LLMProvider
            
            # T·∫°o LLM configuration
            llm_config = LLMConfiguration(
                provider=LLMProvider(provider),
                model_name=model_name,
                temperature=kwargs.get('temperature', 0.1),
                max_tokens=kwargs.get('max_tokens', 1000),
                timeout=kwargs.get('timeout', 30),
                api_key_env=kwargs.get('api_key_env', 'OPENAI_API_KEY'),
                base_url=kwargs.get('base_url')
            )
            
            # C·∫≠p nh·∫≠t
            success = self.config_manager.update_llm_configuration(
                user_id, team_name, llm_config
            )
            
            if success:
                self.logger.info(f"C·∫≠p nh·∫≠t c·∫•u h√¨nh LLM th√†nh c√¥ng cho user {user_id}, team {team_name}")
            else:
                self.logger.error(f"C·∫≠p nh·∫≠t c·∫•u h√¨nh LLM th·∫•t b·∫°i")
            
            log_function_exit(self.logger, "update_user_llm_config", result="success" if success else "error")
            return success
            
        except Exception as e:
            self.logger.error(f"L·ªói khi c·∫≠p nh·∫≠t c·∫•u h√¨nh LLM: {e}", exc_info=True)
            log_function_exit(self.logger, "update_user_llm_config", result="error")
            return False
    
    def get_user_llm_configs(self, user_id: str) -> Optional[Dict[str, Any]]:
        """
        L·∫•y t·∫•t c·∫£ c·∫•u h√¨nh LLM c·ªßa user.
        
        Args:
            user_id: ID ng∆∞·ªùi d√πng
            
        Returns:
            Dict ch·ª©a c·∫•u h√¨nh LLM cho t·ª´ng TEAM
        """
        try:
            user_config = self.config_manager.get_user_configuration(user_id)
            return user_config.llm_configs.to_dict()
        except Exception as e:
            self.logger.error(f"L·ªói khi l·∫•y c·∫•u h√¨nh LLM: {e}")
            return None
    
    def get_available_models(self) -> Dict[str, Any]:
        """
        L·∫•y danh s√°ch model LLM c√≥ s·∫µn.
        
        Returns:
            Dict ch·ª©a c√°c model theo provider
        """
        return self.config_manager.get_available_models()
    
    def _get_session(self, session_id: str) -> Optional[InteractionSession]:
        """L·∫•y session theo ID"""
        return self._active_sessions.get(session_id)
    
    def _create_task_definition(self, task_params: Dict[str, Any], 
                               llm_configs) -> 'TaskDefinition':
        """T·∫°o TaskDefinition t·ª´ task params v√† LLM configs"""
        
        task_type = task_params.get("task_type")
        
        if task_type == "scan_project":
            return self.task_initiator.create_scan_project_task(
                repository_url=task_params["repository_url"],
                llm_configs=llm_configs
            )
        elif task_type == "review_pr":
            return self.task_initiator.create_review_pr_task(
                repository_url=task_params["repository_url"],
                pr_identifier=task_params["pr_identifier"],
                llm_configs=llm_configs
            )
        else:
            raise ValueError(f"Unsupported task type: {task_type}")
    
    def _create_error_response(self, error_message: str) -> Dict[str, Any]:
        """T·∫°o error response"""
        return {
            "session_id": None,
            "message": f"‚ùå {error_message}",
            "state": "error",
            "intent_type": "unknown",
            "intent_confidence": 0.0,
            "suggested_actions": ["Th·ª≠ l·∫°i", "T·∫°o session m·ªõi"],
            "task_ready": False,
            "task_definition": None,
            "conversation_length": 0
        }
    
    def get_active_sessions_count(self) -> int:
        """L·∫•y s·ªë l∆∞·ª£ng session ƒëang ho·∫°t ƒë·ªông"""
        return len(self._active_sessions)
    
    def cleanup_inactive_sessions(self, max_age_hours: int = 24):
        """D·ªçn d·∫πp c√°c session kh√¥ng ho·∫°t ƒë·ªông"""
        # TODO: Implement session expiry logic
        pass 